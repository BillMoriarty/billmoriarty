<h1 id="typescript">TypeScript<a aria-hidden="true" class="anchor-heading icon-link" href="#typescript"></a></h1>
<h3 id="these-are-my-notes-as-i-learn-typescript-and-thus-brush-up-on-modern-javascript"><em>These are my notes as I learn TypeScript, and thus brush up on modern JavaScript.</em><a aria-hidden="true" class="anchor-heading icon-link" href="#these-are-my-notes-as-i-learn-typescript-and-thus-brush-up-on-modern-javascript"></a></h3>
<br>
<p>TypeScript compiles down to JavaScript.</p>
<p>Detects errors in code without running it.
It does this by checking types. </p>
<p>TypeScript is a superset of javascript. </p>
<p>Everything in javascript is valid in TypeScript</p>
<p>Declare a type of a variable.
(This looks just like Swift.)</p>
<blockquote>
<p>let myVar: type = value</p>
</blockquote>
<p><code>let songName: string = "Green Grass";</code></p>
<h3 id="boolean">Boolean<a aria-hidden="true" class="anchor-heading icon-link" href="#boolean"></a></h3>
<p><code>let isDone: boolean = false;</code></p>
<p>Compile by running: <br>
<code>tsc file_name.ts</code></p>
<h3 id="type-inference">Type Inference<a aria-hidden="true" class="anchor-heading icon-link" href="#type-inference"></a></h3>
<p>TypeScript has type inference.
If you explicitly create a variable and set it equal to "hello," then TypeScript will infer it a string.
It is helpful to specify the type, because:</p>
<blockquote>
<p>When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to any.</p>
</blockquote>
<h3 id="any-type">"Any" type<a aria-hidden="true" class="anchor-heading icon-link" href="#any-type"></a></h3>
<p>This defeats the purpose of TypeScript.</p>
<blockquote>
<p>TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors. <br>
When a value is of type any, you can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:</p>
</blockquote>
<p>##xw# Function Definitions</p>
<pre><code>function square(num: number) {
    return num * num;
}

function greet(person: string){
    return `Hi there, ${person}`
}
</code></pre>
<p><em>To provide default value:</em> <br></p>
<pre><code>function greet(person: string = "stranger"){
    return `Hi there, ${person}`
}
</code></pre>
<h3 id="inferring-vs-specifying-return-types">Inferring vs Specifying Return Types<a aria-hidden="true" class="anchor-heading icon-link" href="#inferring-vs-specifying-return-types"></a></h3>
<p>The return value annotation below, ": string",  specifies the return type as string</p>
<pre><code>function greet(person: string = "stranger"): string {
    return `Hi there, ${person}`
}
</code></pre>
<h3 id="specifying-void-return-types">Specifying void return types<a aria-hidden="true" class="anchor-heading icon-link" href="#specifying-void-return-types"></a></h3>
<pre><code>function printIt(strToPrint: string): void{
    console.log(strToPrint)
}
</code></pre>
<h3 id="never">Never<a aria-hidden="true" class="anchor-heading icon-link" href="#never"></a></h3>
<p>"Never" is unique to TypeScript.
It is not void.
Indicates the function should never return anything.
This might be a function that logs an error, or it might be a loop that should never stop.</p>
<h3 id="objects">Objects<a aria-hidden="true" class="anchor-heading icon-link" href="#objects"></a></h3>
<blockquote>
<p>In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types.</p>
</blockquote>
<pre><code>interface Person {
  name: string;
  age: number;
}

</code></pre>
<pre><code>type Person = {
  name: string;
  age: number;
};
</code></pre>
<pre><code>function greet(person: Person) {
  return "Hello " + person.name;
}

</code></pre>
<blockquote>
<p>Much of the time, we’ll find ourselves dealing with objects that might have a property set. In those cases, we can mark those properties as optional by adding a question mark (?) to the end of their names.</p>
</blockquote>
<pre><code>interface PaintOptions {
  shape: Shape;
  xPos?: number;
  yPos?: number;
}

</code></pre>
<h3 id="type-alias">Type Alias<a aria-hidden="true" class="anchor-heading icon-link" href="#type-alias"></a></h3>
<pre><code>type Point = {
    x: number;
    y: number;
}

let coordinate: Point = {x: 32, y: 6};
</code></pre>
<h2 id="intersection-types">Intersection Types<a aria-hidden="true" class="anchor-heading icon-link" href="#intersection-types"></a></h2>
<p>This is interesting - I hadn't seen this idea before.
It's kind of like 'extends' in Java?</p>
<blockquote>
<p>interfaces allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types.</p>
</blockquote>
<p>An intersection type is defined using the &#x26; operator.</p>
<pre><code>interface Colorful {
  color: string;
}
interface Circle {
  radius: number;
}
 
type ColorfulCircle = Colorful &#x26; Circle;
</code></pre>
<blockquote>
<p>Here, we’ve intersected Colorful and Circle to produce a new type that has all the members of Colorful and Circle.</p>
</blockquote>
<h3 id="data-structures">Data Structures<a aria-hidden="true" class="anchor-heading icon-link" href="#data-structures"></a></h3>
<h4 id="array-">Array <br><a aria-hidden="true" class="anchor-heading icon-link" href="#array-"></a></h4>
<blockquote>
<p>TypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by [] to denote an array of that element type:</p>
</blockquote>
<p><code>let numsList: number[] = [1, 2, 3];</code></p>
<p>or</p>
<p><code>let list: Array&#x3C;number> = [1, 2, 3];</code></p>
<h3 id="union-types">Union Types<a aria-hidden="true" class="anchor-heading icon-link" href="#union-types"></a></h3>
<blockquote>
<p>TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, it’s time to start combining them in interesting ways.</p>
</blockquote>
<blockquote>
<p>The first way to combine types you might see is a union type. A union type is a type formed from two or more other types, representing values that may be any one of those types. We refer to each of these types as the union’s members.</p>
</blockquote>
<p>At first glance...I am not sure in what context this feature would be useful. Maybe I'll come across it somewhere.</p>
<pre><code>function printId(id: number | string) {
  if (typeof id === "string") {
    // In this branch, id is of type 'string'
    console.log(id.toUpperCase());
  } else {
    // Here, id is of type 'number'
    console.log(id);
  }
}
</code></pre>
<h3 id="literal-type">Literal Type<a aria-hidden="true" class="anchor-heading icon-link" href="#literal-type"></a></h3>
<p>const zero: number = 0;</p>
<h3 id="some-examples">Some Examples<a aria-hidden="true" class="anchor-heading icon-link" href="#some-examples"></a></h3>
<p>variable that can be a number or boolean
<code>let highScore: number | boolean;</code></p>
<p>array that can hold numbers or strings, but not a mixture <br>
<code>let stuff: number[] | string[] = [];</code></p>
<p>type that holds 4 possible values</p>
<pre class="language-type"><code class="language-type">    "Beginner" |
    "Intermediate" |
    "Advanced" |
    "Expert";
</code></pre>
<pre><code>type RGB = {
    r: number;
    g: number;
    b: number;
}

type HSL = {
    h: number;
    s: number;
    l: number;
}

// array called colors that can hold a mixture of RGB and HSL
const colors: (RGB | HSL)[] = [];
</code></pre>
<h3 id="tuples">Tuples<a aria-hidden="true" class="anchor-heading icon-link" href="#tuples"></a></h3>
<p>This is a TypeScript implementation. In JavaScript it transpiles to an array.
s</p>
<blockquote>
<p>Tuple can contain two values of different data types.</p>
</blockquote>
<pre><code>var empId: number = 1;
var empName: string = "Steve";        

// Tuple type variable 
var employee: [number, string] = [1, "Steve"];

</code></pre>
<blockquote>
<p>A tuple type variable can include multiple data types as shown below.</p>
</blockquote>
<pre><code>var user: [number, string, boolean, number, string];// declare tuple variable
</code></pre>
<blockquote>
<p>You can declare an array of tuple also.</p>
<pre><code>var employee: [number, string][];
employee = [[1, "Steve"], [2, "Bill"], [3, "Jeff"]];
</code></pre>
</blockquote>
<h3 id="enums">Enums<a aria-hidden="true" class="anchor-heading icon-link" href="#enums"></a></h3>
<pre><code>enum Direction {
  Up = 1,
  Down,
  Left,
  Right,
}
</code></pre>
<h3 id="interfaces">Interfaces<a aria-hidden="true" class="anchor-heading icon-link" href="#interfaces"></a></h3>
<p>They allow us to define the structure of objects. </p>
<pre><code>interface Point {
  readonly id: number; // readonly makes it so it cannot be changed
  x: number;
  y: number;
  z?: number; // ? makes this optional
  sayHello: () => string // this indicates the implementation of this interface must include the 'sayHello' method that returns a string and takes no parameters

  sayBye(): string; // another way to write - this indicates the implementation of this interface must include the 'sayBye' method that returns a string and takes no parameters

  changeNums(change: number): number; // this indicates the implementation of this interface must include the 'changeNums' method that returns a string and takes a parameter which is a number. The passed in param name does not need to be called 'change.'

}
</code></pre>
<hr>
<h3 id="aspects-related-to-building-projects-with-typescript">Aspects Related to Building Projects with TypeScript<a aria-hidden="true" class="anchor-heading icon-link" href="#aspects-related-to-building-projects-with-typescript"></a></h3>
<h4 id="as-always-a-todo-list">as always, a TODO List<a aria-hidden="true" class="anchor-heading icon-link" href="#as-always-a-todo-list"></a></h4>
<p>`mkdir project_name</p>
<p>cd project_name</p>
<p>tsc --init</p>
<p>tsc -w `</p>
<p>Now we want to be able to view this in the browser.</p>
<p>To make a live server:</p>
<ul>
<li>keep in mind - below is not a function of TypeScript - this is just a normal npm server...</li>
<li>cd to the base directory of the project</li>
<li>create an npm package file: <code>npm init -y</code></li>
<li>install lite server <code>npm install lite-server</code></li>
<li>setup a script in the newly created npm 'package.json' so that npm start runs lite server, like this:</li>
<li><img src="/assets/images/2022-09-09-11-55-40.png"></li>
<li>run <code>npm start</code></li>
<li>that should launch a browser</li>
<li>when you make a change in your .ts files of the project, they will compile to .js files, and the server is notified, and the changes appear live</li>
</ul>
<p>This returns a generic HTML element. TS doesn't know this a Button</p>
<p>As often when working with the DOM, it's difficult to know if "btn1" will actually exist
<code>const btn = document.getElementById("btn1")</code></p>
<p>One approach is to make them optional:</p>
<pre><code>btn?.addEventListener("click", function ()) {
    console.log("clicked");
}
</code></pre>
<hr>
<p>Calling tsc 'watch' in the terminal will cause node to automatically transpile the .ts into .js on save. <br></p>
<p><code>tsc -w</code></p>
<blockquote>
<p>tsc-watch starts a TypeScript compiler with --watch parameter, with the ability to react to compilation status. tsc-watch was created to allow an easy dev process with TypeScript. Commonly used to restart a node server, similar to nodemon but for TypeScript.</p>
</blockquote>
<hr>
<p>Putting a hash symbol # in front of a property, or method, makes it private to a class. </p>
<hr>
<p>There is some debate here, because the 'private' typescript removes 'private' when it is converted to javascript.</p>
<p>Javascript's way to do this is to use the hashtag in front of a parameter to make it private.</p>
<p><code>#price: number = 0</code></p>
<p><code>private price: number = 0;</code></p>
<hr>
<h2 id="loops">Loops<a aria-hidden="true" class="anchor-heading icon-link" href="#loops"></a></h2>
<p>This looks the same as JavaScript to me</p>
<pre><code>nums.forEach((element, index) => {
        let tmpSum = 0;
    })
</code></pre>
<p>However, since forEach is a function and not a loop, you can't use 'continue' or 'break' to break out of the loop.</p>
<p>If you may need to break the iteration, it's recommended you use something instead of forEach.</p>
<p>Unfortunately, it's also show that hand-rolling for loops often runs quicker than built-in array functions such as map, forEach, etc.</p>
<hr>
<h2 id="array-operations">Array Operations<a aria-hidden="true" class="anchor-heading icon-link" href="#array-operations"></a></h2>
<h3 id="slicing">Slicing<a aria-hidden="true" class="anchor-heading icon-link" href="#slicing"></a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice</a></p>
<p>Slice creates a shallow copy of the array.</p>
<p><strong>start</strong> <br>
Zero-based index at which to start extraction.</p>
<p><strong>end</strong> <br>
The index of the first element to <strong>exclude</strong> from the returned array. Slice extracts up to but not including end. For example, slice(1,4) extracts the second element through the fourth element (elements indexed 1, 2, and 3). Thanks, Mozilla.</p>